// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture



uint Res;

RWTexture2D<float> Front;
RWTexture2D<float> Back;
RWTexture2D<float> Mask;

[numthreads(8, 8, 1)]
void Update(int3 id : SV_DispatchThreadID)
{
	if (!Mask[id.xy]) return;

	float C = 0.6f;
	//float C = 0.3f;

	float nCount = 0;
	float nTotal = 0;

	/*
	N	Cur	Ideal
	0	0	0
	1	.25	.125
	2	.5	.25
	3	.75	.5
	4	1	1
	
	
	
	*/


	int hasNeighbor;
	int2 v;

	// N1
	v = id.xy + int2(0, 1);
	hasNeighbor = Mask[v]; // Needs terrain check
	nCount += hasNeighbor;
	nTotal += hasNeighbor * Back[v];
	
	// N2
	v = id.xy + int2(-1, 1 - (id.x & 1));
	hasNeighbor = Mask[v]; // Needs terrain check
	nCount += hasNeighbor;
	nTotal += hasNeighbor * Back[v];

	// N3
	v = id.xy + int2(-1, -(id.x & 1));
	hasNeighbor = Mask[v]; // Needs terrain check
	nCount += hasNeighbor;
	nTotal += hasNeighbor * Back[v];
	
	// N4
	v = id.xy + int2(0, -1);
	hasNeighbor = Mask[v]; // Needs terrain check
	nCount += hasNeighbor;
	nTotal += hasNeighbor * Back[v];
	
	// N5
	v = id.xy + int2(1, -(id.x & 1));
	hasNeighbor = Mask[v]; // Needs terrain check
	nCount += hasNeighbor;
	nTotal += hasNeighbor * Back[v];
	
	// N6
	v = id.xy + int2(1, 1 - (id.x & 1));
	hasNeighbor = Mask[v]; // Needs terrain check
	nCount += hasNeighbor;
	nTotal += hasNeighbor * Back[v];
	

	if (nCount == 0) return;

	//float nMod = 4 * pow(0.5f, 4 - nCount) / nCount;

	Front[id.xy] = Back[id.xy] + 0.995f * (Back[id.xy] - Front[id.xy]) + C * C * (nTotal - nCount * Back[id.xy]); // Switch 0 to Terrain
	//Front[id.xy] = nCount;
}

int HasNeighbor(uint2 id, uint x, uint y) {
	return x + Res * y;
}

/*
    5---------6
   /           \
  /             \
 /               \
4        +        1
 \               /
  \             /
   \           /
    3---------2


*/